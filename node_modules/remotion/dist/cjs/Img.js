"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Img = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const delay_render_js_1 = require("./delay-render.js");
const prefetch_js_1 = require("./prefetch.js");
function exponentialBackoff(errorCount) {
    return 1000 * 2 ** (errorCount - 1);
}
const ImgRefForwarding = ({ onError, maxRetries = 2, src, ...props }, ref) => {
    const imageRef = (0, react_1.useRef)(null);
    const errors = (0, react_1.useRef)({});
    (0, react_1.useImperativeHandle)(ref, () => {
        return imageRef.current;
    }, []);
    const actualSrc = (0, prefetch_js_1.usePreload)(src);
    const retryIn = (0, react_1.useCallback)((timeout) => {
        if (!imageRef.current) {
            return;
        }
        const currentSrc = imageRef.current.src;
        setTimeout(() => {
            var _a;
            if (!imageRef.current) {
                // Component has been unmounted, do not retry
                return;
            }
            const newSrc = (_a = imageRef.current) === null || _a === void 0 ? void 0 : _a.src;
            if (newSrc !== currentSrc) {
                // src has changed, do not retry
                return;
            }
            imageRef.current.removeAttribute('src');
            imageRef.current.setAttribute('src', newSrc);
        }, timeout);
    }, []);
    const didGetError = (0, react_1.useCallback)((e) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (!errors.current) {
            return;
        }
        errors.current[(_a = imageRef.current) === null || _a === void 0 ? void 0 : _a.src] =
            ((_c = errors.current[(_b = imageRef.current) === null || _b === void 0 ? void 0 : _b.src]) !== null && _c !== void 0 ? _c : 0) + 1;
        if (onError &&
            ((_e = errors.current[(_d = imageRef.current) === null || _d === void 0 ? void 0 : _d.src]) !== null && _e !== void 0 ? _e : 0) > maxRetries) {
            onError(e);
            return;
        }
        if (((_g = errors.current[(_f = imageRef.current) === null || _f === void 0 ? void 0 : _f.src]) !== null && _g !== void 0 ? _g : 0) <= maxRetries) {
            const backoff = exponentialBackoff((_j = errors.current[(_h = imageRef.current) === null || _h === void 0 ? void 0 : _h.src]) !== null && _j !== void 0 ? _j : 0);
            console.warn(`Could not load image with source ${(_k = imageRef.current) === null || _k === void 0 ? void 0 : _k.src}, retrying again in ${backoff}ms`);
            retryIn(backoff);
            return;
        }
        console.error('Error loading image with src:', (_l = imageRef.current) === null || _l === void 0 ? void 0 : _l.src, e, 'Handle the event using the onError() prop to make this message disappear.');
    }, [maxRetries, onError, retryIn]);
    if (typeof window !== 'undefined') {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, react_1.useLayoutEffect)(() => {
            if (process.env.NODE_ENV === 'test') {
                return;
            }
            const newHandle = (0, delay_render_js_1.delayRender)('Loading <Img> with src=' + src);
            const { current } = imageRef;
            const onComplete = () => {
                var _a, _b, _c, _d;
                if (((_b = errors.current[(_a = imageRef.current) === null || _a === void 0 ? void 0 : _a.src]) !== null && _b !== void 0 ? _b : 0) > 0) {
                    delete errors.current[(_c = imageRef.current) === null || _c === void 0 ? void 0 : _c.src];
                    console.info(`Retry successful - ${(_d = imageRef.current) === null || _d === void 0 ? void 0 : _d.src} is now loaded`);
                }
                (0, delay_render_js_1.continueRender)(newHandle);
            };
            const didLoad = () => {
                onComplete();
            };
            if (current === null || current === void 0 ? void 0 : current.complete) {
                onComplete();
            }
            else {
                current === null || current === void 0 ? void 0 : current.addEventListener('load', didLoad, { once: true });
            }
            // If tag gets unmounted, clear pending handles because image is not going to load
            return () => {
                current === null || current === void 0 ? void 0 : current.removeEventListener('load', didLoad);
                (0, delay_render_js_1.continueRender)(newHandle);
            };
        }, [src]);
    }
    return ((0, jsx_runtime_1.jsx)("img", { ...props, ref: imageRef, src: actualSrc, onError: didGetError }));
};
/**
 * @description Works just like a regular HTML img tag. When you use the <Img> tag, Remotion will ensure that the image is loaded before rendering the frame.
 * @see [Documentation](https://www.remotion.dev/docs/img)
 */
exports.Img = (0, react_1.forwardRef)(ImgRefForwarding);
