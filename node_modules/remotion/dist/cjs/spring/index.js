"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.measureSpring = exports.spring = void 0;
const validate_frame_js_1 = require("../validate-frame.js");
const validate_fps_js_1 = require("../validation/validate-fps.js");
const validation_spring_duration_js_1 = require("../validation/validation-spring-duration.js");
const measure_spring_js_1 = require("./measure-spring.js");
const spring_utils_js_1 = require("./spring-utils.js");
/**
 * @description Calculates a position based on physical parameters, start and end value, and time.
 * @see [Documentation](https://www.remotion.dev/docs/spring)
 * @param {number} frame The current time value. Most of the time you want to pass in the return value of useCurrentFrame.
 * @param {number} fps The framerate at which the animation runs. Pass in the value obtained by `useVideoConfig()`.
 * @param {?boolean} reverse Whether the animation plays in reverse or not. Default `false`.
 * @param {?Object} config optional object that allows you to customize the physical properties of the animation.
 * @param {number} [config.mass=1] The weight of the spring. If you reduce the mass, the animation becomes faster!
 * @param {number} [config.damping=10] How hard the animation decelerates.
 * @param {number} [config.stiffness=100] Affects bounciness of the animation.
 * @param {boolean} [config.overshootClamping=false] Whether to prevent the animation going beyond the target value.
 * @param {?number} [config.from] The initial value of the animation. Default `0`
 * @param {?number} [config.to] The end value of the animation. Default `1`
 * @param {?number} [config.durationInFrames] Stretch the duration of an animation to  a set value.. Default `undefined`
 * @param {?number} [config.durationThreshold] How close to the end the animation is considered to be done. Default `0.005`
 * @param {?number} [config.delay] Delay the animation for this amount of frames. Default `0`
 */
function spring({ frame: passedFrame, fps, config = {}, from = 0, to = 1, durationInFrames: passedDurationInFrames, durationRestThreshold, delay = 0, reverse = false, }) {
    (0, validation_spring_duration_js_1.validateSpringDuration)(passedDurationInFrames);
    (0, validate_frame_js_1.validateFrame)({
        frame: passedFrame,
        durationInFrames: Infinity,
        allowFloats: true,
    });
    (0, validate_fps_js_1.validateFps)(fps, 'to spring()', false);
    const needsToCalculateNaturalDuration = reverse || typeof passedDurationInFrames !== 'undefined';
    const naturalDuration = needsToCalculateNaturalDuration
        ? (0, measure_spring_js_1.measureSpring)({
            fps,
            config,
            from,
            to,
            threshold: durationRestThreshold,
        })
        : undefined;
    const naturalDurationGetter = needsToCalculateNaturalDuration
        ? {
            get: () => naturalDuration,
        }
        : {
            get: () => {
                throw new Error('did not calculate natural duration, this is an error with Remotion. Please report');
            },
        };
    const frame = (reverse
        ? (passedDurationInFrames !== null && passedDurationInFrames !== void 0 ? passedDurationInFrames : naturalDurationGetter.get()) - passedFrame
        : passedFrame) - delay;
    const spr = (0, spring_utils_js_1.springCalculation)({
        fps,
        frame: passedDurationInFrames === undefined
            ? frame
            : frame / (passedDurationInFrames / naturalDurationGetter.get()),
        config,
        from,
        to,
    });
    if (!config.overshootClamping) {
        return spr.current;
    }
    if (to >= from) {
        return Math.min(spr.current, to);
    }
    return Math.max(spr.current, to);
}
exports.spring = spring;
var measure_spring_js_2 = require("./measure-spring.js");
Object.defineProperty(exports, "measureSpring", { enumerable: true, get: function () { return measure_spring_js_2.measureSpring; } });
